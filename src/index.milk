// -*-javascript-*-

fs = require('fs')
path = require('path').posix
marked = require('marked').setOptions({ smartypants: true })
milk = require('milk-lang')

cache = {}

class ReticuleRenderer extends marked.Renderer:
    function init(dirname, sectionpath):
        self.keywords = []
        self.dirname = dirname
        self.relative = path.join(path.relative(path.join(dirname, sectionpath), dirname), './')
        super.init()

    function code(code):
        return '<p class="math">$$$' + code + '$$$</p>'

    function codespan(code):
        return '<span class="math">$' + code + '$</span>'

    function link(href, title, text):
        out = '<a '

        if href[0] == '#':
            tag = exports.getTagById(self.dirname, href)
            href = path.join(self.relative, tag.path) + tag.id
            out += 'class="tag" data-path="' + tag.path + tag.id + '" '

        out += 'href="' + href + '"'
        if title: out += 'title="' + title + '"'
        out += '>' + text + '</a>'

        return out

    function del(text):
        if text not in self.keywords:
            self.keywords.push(text)
        return ''

function readdirRecursive(dirname):
    items = [path.join(dirname, item) for item in fs.readdirSync(dirname)]

    for item in items if fs.statSync(item).isDirectory():
        items = items.concat(readdirRecursive(item))

    return items

function fillTemplate(template, context):
    escaperegex = x => x.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")

    for k, v in context:
        template = template.replace(new RegExp('{{' + escaperegex(k) + '}}', 'g'), v)

    return template

getInfo = JSON.parse @ fs.readFileSync(_, 'utf8') @ path.join

exports.getBookInfo = getInfo(_, 'book.json')

exports.getSectionInfo = getInfo(_, 'section.json')

exports.getToc = function(dirname):
    items = [path.join(dirname, item) for item in fs.readdirSync(dirname)]
    toc = []
    output = toc

    for item in items: try:
        info = exports.getSectionInfo(item)
        info.type = 'section'
        info.path = path.relative(dirname, item)
        subtoc = exports.getToc(item)

        if subtoc.length > 0: info.toc = subtoc
        toc.push(info)

    return output

exports.getLinearToc = function(toc):
    linear = []

    for item in toc:
        if 'toc' in item:
            sublinear = exports.extractLinearToc(item.toc)
            linear = linear.concat(sublinear)
        else:
            linear.push(item)

    return linear

exports.renderToc = function(toc, relative = './', currentpath = null):
    output = '<ol class="toc">\n'

    for item in toc:
        a = item.title
        if 'toc' not in item:
            a = '<a href="' + path.join(relative, item.path)
                + '" data-path="' + item.path + '">' + item.title + '</a>'

        li = '<li>' + a
        if currentpath == item.path:
            li = '<li class="current">' + a

        if 'toc' in item:
            subtoc = exports.renderToc(item.toc, relative, currentpath)
            li += subtoc

        li += '</li>\n'
        output += li

    return output + '</ol>'

exports.extractTags = function(filename, dirname):
    if filename not in cache:
        tags = []

        try:
            content = fs.readFileSync(filename, 'utf8').replace(/\r\n/g, '\n').split('\n')
            tagheaders = [first, ...] => first == '#'
            tagslength = content.filter(tagheaders).length

            if tagslength == 0: return []
            for i, l in content if tagheaders(l): break

            while tags.length < tagslength:
                for j in [i + 1 ...] if j == content.length || tagheaders(content[j]): break

                tag = exports.parseTag(content[i ... j - 1])
                tag.path = path.relative(dirname, path.join(filename, '..'))
                tags.push(tag)

                i = j

        cache[filename] = tags

    return cache[filename]

exports.renderTags = function(tags, dirname):
    output = ''
    keywords = {}

    for tag in tags:
        renderer = new ReticuleRenderer(dirname, tag.path)
        options = { renderer }
        output += '<article id="' + tag.id[1...] + '">\n' + marked(tag.assertion, options) + '\n'

        if tag.proof != null:
            output += marked(tag.proof, options) + '\n<p class="qed">$\\square$</p>'

        output += '</article>\n'

        for keyword in renderer.keywords:
            if keyword not in keywords:
                keywords[keyword] = [[tag.path, tag.id]]
            else:
                keywords[keyword].push([tag.path, tag.id])

    return [output, keywords]

exports.parseTag = function(lines):
    separator = x => x != '' && x.split('').every(y => y == '-')
    for k in [0...] if k == lines.length || separator(lines[k]): break

    j = lines[0].indexOf(':')
    id = j == -1 ? lines[0] : lines[0].substring(0, j)
    type = j == -1 ? '' : lines[0].substring(j + 1)
    assertion = lines[1 ... k - 1].join('\n').trim()
    proof = k + 1 < lines.length
        ? lines[k + 1 ...].join('\n').trim()
        : null

    prefix = '<a class="label" href="' + id + '">'
    if type.trim() != '':
        prefix += type + ' ' + id[1...].replace(/-/g, '.') + '.</a>\n\n'
    else:
        prefix += '&para;</a>\n\n'

    assertion = prefix + assertion

    if proof != null:
        prefix = '<strong class="label">Proof.</strong>\n\n'
        proof = prefix + proof

    return { id, type, assertion, proof }

exports.renderIndex = function(keywords, relative = './'):
    output = '<ul class="index">\n'

    compare = (p, q, f) => f(p) == f(q) ? 0 : f(p) < f(q) ? -1 : 1
    keys = Object.keys(keywords)
    keys.sort(compare(_, _, x => x.toLowerCase().replace(/\W/g, '')))

    if keys.length == 0:
        return '<p>No index.</p>'

    for keyword in keys:
        output += '<li><span>' + keyword + '</span> '

        for [p, id] in keywords[keyword]:
            output += '<a href="' + path.join(relative, p) + id
                + '" data-path="' + p + id + '" class="tag index">'
                + id[1...] + '</a> '

        output += '</li>\n'

    return output + '</ul>'

exports.renderLinearNav = function(prev, next, relative = './'):
    output = '<p class="nav">\n'

    if prev != null:
        output += '<a href="' + path.join(relative, prev.path) + '" class="prev">&laquo; ' + prev.title + '</a>\n'
    if next != null:
        output += '<a href="' + path.join(relative, next.path) + '" class="next">' + next.title + ' &raquo;</a>\n'

    return output + '</p>'

exports.getAllTags = function(dirname):
    if dirname not in cache:
        files = readdirRecursive(dirname).filter(x => path.basename(x) == 'tags.md')
        tags = []

        for file in files:
            tags = tags.concat(exports.extractTags(file, dirname))

        cache[dirname] = tags

    return cache[dirname]

exports.getTagById = function(dirname, id):
    return exports.getAllTags(dirname).filter(tag => tag.id == id)[0] ?? null

exports.buildReticule = function(dirname):
    template = fs.readFileSync('../view/index.html', 'utf8')
    bookinfo = exports.getBookInfo(dirname)

    console.log('Generate table of contents...')

    toc = exports.getToc(dirname)
    toc.push({ path: 'index', title: 'Index' })
    linear = exports.getLinearToc(toc)

    tags = exports.getAllTags(dirname)
    items = []
    keywords = {}

    for item in tags.map(tag => tag.path) if item not in items:
        items.push(item)
        console.log('Processing ' + item + '...')

        try: fs.statSync(path.join(dirname, item, 'tags.md'))
        catch: continue

        // Load data
        sectioninfo = exports.getSectionInfo(path.join(dirname, item))
        tags = exports.extractTags(path.join(dirname, item, 'tags.md'), dirname)

        [html, kw] = exports.renderTags(tags, dirname)
        relative = path.join(path.relative(path.join(dirname, item), dirname), './')

        // Handle index
        for keyword, value in kw:
            if keyword not in keywords:
                keywords[keyword] = value
            else:
                keywords[keyword] = keywords[keyword].concat(value)

        // Look for prev/next section
        for k, i in linear if i.path == item: break
        nav = exports.renderLinearNav(linear[k - 1] ?? {
            title: 'Table of Contents'
            path: './'
        }, linear[k + 1], relative)

        // Write data
        fs.writeFileSync(path.join(dirname, item, 'index.html'), fillTemplate(template, {
            title: bookinfo.title
            toc: exports.renderToc(toc, relative, item)
            relative
            main: [
                '<h1>' + sectioninfo.title + '</h1>'
                nav
                html
                nav
            ].join('\n')
        }))

    console.log('Create front page...')

    nav = exports.renderLinearNav(null, linear[0], './')

    fs.writeFileSync(path.join(dirname, 'index.html'), fillTemplate(template, {
        title: bookinfo.title
        toc: exports.renderToc(toc)
        relative: './'
        main: [
            '<h1>' + bookinfo.title + '</h1>'
            '<p class="meta">' + bookinfo.author + '</p>'
            '<h2>Table of Contents</h2>'
            exports.renderToc(toc).replace(/<ol/g, '<ul').replace(/<\/ol>/g, '</ul>')
            nav
        ].join('\n')
    }))

    console.log('Generate index...')

    nav = exports.renderLinearNav(linear[linear.length - 1], null, '../')

    try: fs.mkdirSync(path.join(dirname, 'index'))
    fs.writeFileSync(path.join(dirname, 'index/index.html'), fillTemplate(template, {
        title: bookinfo.title
        toc: exports.renderToc(toc, '../', 'index')
        relative: '../'
        main: [
            '<h1>Index</h1>'
            nav
            '<article>'
            exports.renderIndex(keywords, '../', dirname)
            '</article>'
            nav
        ].join('\n')
    }))

    console.log('Copy resources...')

    fs.writeFileSync(path.join(dirname, 'reticule.css'), fs.readFileSync('../view/reticule.css'))
    code = milk.compile(fs.readFileSync('../view/reticule.milk', 'utf8'))
    fs.writeFileSync(path.join(dirname, 'reticule.js'), code)

    console.log('Done.')
