fs = require('fs')
path = require('path')
marked = require('marked')
ReticuleRenderer = require('./renderers').ReticuleRenderer

cache = {}
marked.setOptions({
    smartypants: true
    renderer: new ReticuleRenderer()
})

function readdirRecursive(dirname):
    items = [path.join(dirname, item) for item in fs.readdirSync(dirname)]

    for item in items if fs.statSync(item).isDirectory():
        items = items.concat(readdirRecursive(item))

    return items

getInfo = JSON.parse @ fs.readFileSync(_, 'utf8') @ path.join

exports.getBookInfo = getInfo(_, 'book.json')

exports.getSectionInfo = getInfo(_, 'section.json')

exports.getToc = function(dirname):
    items = [path.join(dirname, item) for item in fs.readdirSync(dirname)]
    toc = []

    try:
        info = exports.getBookInfo(dirname)
        info.type = 'book'
        if 'title' in info: info.title = marked(info.title)
        toc.push(info)

        info.subtoc = []
        toc = info.subtoc

    for item in items: try:
        info = exports.getSectionInfo(item)
        info.type = 'section'
        info.path = item
        if 'title' in info: info.title = marked(info.title)
        subtoc = exports.getToc(item)

        if subtoc.length > 0: info.toc = subtoc
        toc.push(info)

    return toc

exports.extractTags = function(filename):
    if filename not in cache:
        tags = []

        try:
            content = fs.readFileSync(filename, 'utf8').replace(/\r\n/g, '\n').split('\n')
            tagheaders = [first, ...] => first == '#'
            tagslength = content.filter(tagheaders).length

            if length == 0: return []
            for i, l in content if tagheaders(l): break

            while tags.length < tagslength:
                for j in [i + 1 ...] if !content[j] || tagheaders(content[j]): break

                tag = exports.parseTag(content[i ... j - 1])
                tag.path = path.join(filename, '..')
                tags.push(tag)

                i = j

        cache[filename] = tags

    return cache[filename]

exports.parseTag = function(lines):
    separator = x => x.split('').every(y => y == '-')
    for k in [0...] if !lines[k] || separator(lines[k]): break

    assertion = lines[1 ... k - 1].join('\n')
    proof = k + 1 < lines.length ? lines[k + 1 ...].join('\n') : null

    return {
        id: lines[0]
        assertion: marked(assertion)
        proof: marked(proof)
    }

exports.getAllTags = function(dirname):
    if dirname not in cache:
        files = readdirRecursive(dirname).filter(x => path.basename(x) == 'tags.md')
        tags = []

        for file in files:
            tags = tags.concat(exports.extractTags(file))

        cache[dirname] = tags

    return cache[dirname]

exports.getTagById = function(dirname, id):
    return exports.getAllTags(dirname).filter(tag => tag.id == id)[0] ?? null

exports.buildReticule = function(dirname):
    saveJson = filename => fs.writeFileSync(filename, _, 'utf8') @ JSON.stringify

    toc = exports.getToc(dirname)
    saveJson(path.join(dirname, 'toc.json'))(toc)

    for item in exports.getAllTags(dirname).map(tag => tag.path):
        if fs.stat(path.join(item, 'tags.json')).isFile()
        || !fs.stat(path.join(item, 'tags.md')).isFile(): continue

        tags = exports.extractTags(path.join(item, 'tags.md'))
        saveJson(path.join(item, 'tags.json'))(tags)
