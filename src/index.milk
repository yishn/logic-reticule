fs = require('fs')
path = require('path').posix
marked = require('marked')
milk = require('milk-lang')
ReticuleRenderer = require('./renderers').ReticuleRenderer

cache = {}
marked.setOptions({
    smartypants: true
    renderer: new ReticuleRenderer()
})

function readdirRecursive(dirname):
    items = [path.join(dirname, item) for item in fs.readdirSync(dirname)]

    for item in items if fs.statSync(item).isDirectory():
        items = items.concat(readdirRecursive(item))

    return items

escaperegex = x => x.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")

function fillTemplate(template, context):
    for k, v in context:
        template = template.replace(new RegExp('{{' + escaperegex(k) + '}}', 'g'), v)

    return template

getInfo = JSON.parse @ fs.readFileSync(_, 'utf8') @ path.join

exports.getBookInfo = getInfo(_, 'book.json')

exports.getSectionInfo = getInfo(_, 'section.json')

exports.getToc = function(dirname):
    items = [path.join(dirname, item) for item in fs.readdirSync(dirname)]
    toc = []
    output = toc

    for item in items: try:
        info = exports.getSectionInfo(item)
        info.type = 'section'
        info.path = item
        subtoc = exports.getToc(item)

        if subtoc.length > 0: info.toc = subtoc
        toc.push(info)

    return output

exports.renderToc = function(toc, relative = './'):
    output = '<ol>\n'

    for item in toc:
        a = '<a href="' + path.join(relative, item.path) + '">' + item.title + '</a>'
        li = '<li>' + a

        if 'toc' in item:
            subtoc = exports.renderToc(item.toc, relative)
            li += subtoc

        li += '</li>\n'
        output += li

    return output + '</ol>'

exports.extractTags = function(filename):
    if filename not in cache:
        tags = []

        try:
            content = fs.readFileSync(filename, 'utf8').replace(/\r\n/g, '\n').split('\n')
            tagheaders = [first, ...] => first == '#'
            tagslength = content.filter(tagheaders).length

            if tagslength == 0: return []
            for i, l in content if tagheaders(l): break

            while tags.length < tagslength:
                for j in [i + 1 ...] if j == content.length || tagheaders(content[j]): break

                tag = exports.parseTag(content[i ... j - 1])
                tag.path = path.join(filename, '..')
                tags.push(tag)

                i = j

        cache[filename] = tags

    return cache[filename]

exports.renderTags = function(tags):
    output = ''

    for tag in tags:
        output += '<article>\n' + tag.assertion + '\n'

        if tag.proof != null:
            output += tag.proof + '\n'

        output += '</article>\n'

    return output

exports.parseTag = function(lines):
    separator = x => x != '' && x.split('').every(y => y == '-')
    for k in [0...] if k == lines.length || separator(lines[k]): break

    j = lines[0].indexOf(':')
    id = j == -1 ? lines[0] : lines[0].substring(0, j)
    type = j == -1 ? '' : lines[0].substring(j + 1)
    assertion = marked(lines[1 ... k - 1].join('\n').trim())
    proof = k + 1 < lines.length
        ? marked(lines[k + 1 ...].join('\n').trim() + ' <span class="qed">$\\square$</span>')
        : null

    if type.trim() != '':
        if assertion[0...2] == '<p>':
            assertion = '<p><strong class="label">' + type + ' ' + id + '.</strong> ' + assertion[3...]
        else:
            assertion = '<p><strong class="label">' + type + ' ' + id + '.</strong></p>\n' + assertion

    if proof != null:
        if proof[0...2] == '<p>':
            proof = '<p><strong class="label">Proof.</strong> ' + proof[3...]
        else:
            proof = '<p><strong class="label">Proof.</strong></p>\n' + proof

    return { id, type, assertion, proof }

exports.getAllTags = function(dirname):
    if dirname not in cache:
        files = readdirRecursive(dirname).filter(x => path.basename(x) == 'tags.md')
        tags = []

        for file in files:
            tags = tags.concat(exports.extractTags(file))

        cache[dirname] = tags

    return cache[dirname]

exports.getTagById = function(dirname, id):
    return exports.getAllTags(dirname).filter(tag => tag.id == id)[0] ?? null

exports.buildReticule = function(dirname):
    bookinfo = exports.getBookInfo(dirname)
    saveJson = filename => fs.writeFileSync(filename, _) @ JSON.stringify(_, null, '  ')

    template = fs.readFileSync('../view/index.html', 'utf8')
    toc = exports.getToc(dirname)

    // Compile sections

    tags = exports.getAllTags(dirname)
    items = []

    for item in tags.map(tag => tag.path) if item not in items:
        items.push(item)

        try: fs.statSync(path.join(item, 'tags.md'))
        catch: continue

        sectioninfo = exports.getSectionInfo(item)
        tags = exports.extractTags(path.join(item, 'tags.md'))
        saveJson(path.join(item, 'tags.json'))(tags)

        relative = path.join(path.relative(item, dirname), './')
        fs.writeFileSync(path.join(item, 'index.html'), fillTemplate(template, {
            title: bookinfo.title
            toc: exports.renderToc(toc, relative)
            relative
            main: [
                '<h1>' + sectioninfo.title + '</h1>'
                exports.renderTags(tags)
            ].join('\n')
        }))

    // Create front page

    fs.writeFileSync(path.join(dirname, 'index.html'), fillTemplate(template, {
        title: bookinfo.title
        toc: exports.renderToc(toc)
        relative: './'
        main: marked([
            '# ' + bookinfo.title
            '<p class="meta">by ' + bookinfo.author + '</p>'
            '## Table of Contents'
            '<ol class="toc">'
            exports.renderToc(toc)[4...]
        ].join('\n'))
    }))

    // Copy resources

    fs.writeFileSync(path.join(dirname, 'reticule.css'), fs.readFileSync('../view/reticule.css'))
    code = milk.compile(fs.readFileSync('../view/reticule.milk', 'utf8'))
    fs.writeFileSync(path.join(dirname, 'reticule.js'), code)
